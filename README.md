# REST-API условного маркетплейса
[![CI](https://github.com/justcgh9/vk-internship-application/actions/workflows/main.yml/badge.svg)](https://github.com/justcgh9/vk-internship-application/actions/workflows/main.yml)
[![Test Coverage Status](https://coveralls.io/repos/github/justcgh9/vk-internship-application/badge.svg?branch=main)](https://coveralls.io/github/justcgh9/vk-internship-application)
![License](https://img.shields.io/badge/license-MIT-blue.svg)
![Go Version](https://img.shields.io/badge/go-1.24-blue)

## Оглавление

- [О проекте](#о-проекте)
- [Технологии и особенности реализации](#технологии-и-особенности-реализации)
- [Спорные моменты](#спорные-моменты)
- [Инструкция по запуску](#инструкция-по-запуску)

---


## О проекте

Данный проект реализует базовый REST API, влкючающий в себя систему регистрации, авторизации пользователей и управления объявлениями. Для Вашего удобства, я задокументировал получившийся интрефейс в [openapi.yml](/api/openapi.yml) в формате OpenAPI 3.0. Его можно вставить в подходящий редактор, например, [swagger](https://editor.swagger.io/) для получения удобного графического интерфейса. Оговорюсь, что в `swagger` протестировать эндпоинты через GUI у меня так и не удалось, но сгенерированные `curl` команды работали исправно. В данный момент проект опубликован на данном домене `papaya-copper13073.my-vm.work`, по 80 порту. SSL сертификат к моменту дедлайна получить не получилось, так как сервера `letsencrypt` постоянно были заняты, поэтому доступ только по `http`.

**Основной функционал**:

 - Регистрация и авторизация пользователей с выдачей JWT-токена;

 - Создание объявлений авторизованными пользователями;

 - Получение списка объявлений с поддержкой фильтрации и сортировки;

 - Возвращение дополнительной информации о владельце объявления (если доступна).  


---

## Технологии и особенности реализации

Имплементация данного проекта является достаточно типовой: вся необходимая логика находится внутри папки `internal` и разделена на три основных слоя:

- Транспортный (HTTP хэндлеры и middleware);
- Сервисный (Основная бизнес логика);
- Репозиторийный (Работа с базой данных).

Для взаимодействия с сервисным и репозиторийным слоями описаны интерфейсы, которым они удовлетворяют, чтобы в случае необходимости можно было легко подменить реализацию (например, использовать другую БД). К слову, в качестве хранилища используется PostgreSQL и pgx драйвер по ряду причин: 

1. Реляционная природа наших данных 
2. Требования по сортировкам и фильтрам
3. Поддержка транзакций (может быть критично, особенно при будущей реализации механизмов оплаты для покупок товаров по объявлениям)
4. Удобство масштабирования в продакшене (при необходимости)

Для регистрации и авторизации используется обертка поверх библиотечного JWT функционала. Можно было бы добавить механизм с использованием долгоживущего `refresh` токена, например, в куках, но такие требования отсутствовали. 

На транспортном уровне использовался `chi` роутер и валидатор от `go-playground`. Вполне можно было бы воспользоваться фреймворками вроде `gin` или `fiber`, но я посчитал их избыточными для такого скромного проекта. Для валидации же, я решил не писать свои костыли, а воспользоваться готовым и лаконичным решением.

Приложение конфигурируется с помощью `yaml` конфигов, образец можно найти [здесь](/config/local.yml), а полную структуру [тут](/internal/config/config.go). Путь к конфигу указывается через флаг при запуске, подробнее будет описано в главе с инструкцией по запуску. 

Оно упаковывается в `Docker` контейнер, в котором есть только конфиг и бинарный файл, а также отсутствуют рутовые права. Помимо этого, я постарался сохранить чистый `.dockerignore`.

Я постарался достичь адекватного тестового покрытия, но так как проект игрушечный - некоторая часть кода, в которой не описана значимая логика, не требует покрытия тестами. Итоговый уровень покрытия вы можете увидеть в бадже вверху данного документа

Так же я добавил инструменты для наблюдаемости - экспорт метрик с помощью `Prometheus` и трейсов с помощью `Jaeger`. В коде добавлены самые простые примеры, так как чего-то более сложного сразу в голову не пришло, а изощряться не хотелось. Ниже прикладываю несколько примеров того, как это выглядит:

![grafana-pic](/media/Screenshot%20from%202025-07-21%2022-37-20.png)
![jaeger-pic](/media/Screenshot%20from%202025-07-21%2022-41-25.png)

В будущем можно было бы добавить агрегацию логов, но она банально не поместилась в ограниченные ресурсы моего хиленького VDS-а.

---

## Спорные моменты

В данной главе будут описаны решения, которые я принял, когда данные требования можно было толковать по-разному.

### Валидация изображений

Одним из требований было предусмотрение разумных ограничений на размер и формат изображения. Данное требование показалось мне спорным, поскольку изображение не передается напрямую - передается только ссылка. В ответ на данный вопрос мне сказали, что я могу имплементировать это как захочу - от загрузки файла напрямую, до использования ссылки в json-е. Я оставил тело запроса в формате JSON - как в оригинальных требованиях и добавил валидацию через дополнительный http запрос. После небольшого ручного тестирования среднее время ответа ручки без/с валидацией отличалось примерно в 8 раз (8-11 мс против 80 - 100 мс), но данную проверку легко отключить [здесь](https://github.com/justcgh9/vk-internship-application/blob/main/internal/http/handlers/listings/create.go#L40)

---

## Инструкция по запуску

Для того, чтобы успешно запустить приложение нам понадобится `Docker`, для удобства можно воспользоваться утилитой [`task`](https://taskfile.dev/).

Первым делом нам нужно описать необходимые для базы данных переменные окружения в `.env` файле, прикладываю пример того, как это можно сделать:

```env
POSTGRES_USER=marketplace
POSTGRES_PASSWORD=marketplace_pass
POSTGRES_DB=marketplace_db
POSTGRES_USER=marketplace_usr
POSTGRES_HOST=localhost
POSTGRES_PORT=5432
```

Далее можно запускать бд с помощью команды

```sh
docker compose up -d db 
```

Теперь необходимо применить миграции. Это можно сделать двумя способами:

- Утилитой `task`:

```bash
task migrate:up
```

- Вручную (необходимые переменные либо вставьте вручную, либо добавьте в окружение)

```bash
go run cmd/migrator/main.go -db "postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}?sslmode=disable" -path "./migrations" -action up 
```

Далее нужно добавить конфиг приложения и указать к нему путь в `docker-compose.yml`, пример уже лежит [здесь](/config/local.yml). Если вы хотите воспользоваться предоставленным примером, то измените [здесь](https://github.com/justcgh9/vk-internship-application/blob/main/docker-compose.yml#L7) `CONFIG_PATH: ./config/prod.yml` на `CONFIG_PATH: ./config/local.yml`

Теперь можно собирать и запускать приложение:

```bash
docker compose up -d app --build
```

